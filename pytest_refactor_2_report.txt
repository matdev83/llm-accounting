============================= test session starts ==============================
platform linux -- Python 3.10.17, pytest-8.3.5, pluggy-1.5.0 -- /usr/local/bin/python
cachedir: .pytest_cache
metadata: {'Python': '3.10.17', 'Platform': 'Linux-6.8.0-x86_64-with-glibc2.39', 'Packages': {'pytest': '8.3.5', 'pluggy': '1.5.0'}, 'Plugins': {'cov': '5.0.0', 'mock': '3.14.0', 'asyncio': '0.23.7', 'Faker': '25.0.0', 'anyio': '4.9.0', 'json-report': '1.5.0', 'metadata': '3.1.1'}}
rootdir: /app
configfile: pytest.ini
testpaths: tests
plugins: cov-5.0.0, mock-3.14.0, asyncio-0.23.7, Faker-25.0.0, anyio-4.9.0, json-report-1.5.0, metadata-3.1.1
asyncio: mode=strict
collecting ... collected 226 items / 1 deselected / 225 selected

tests/accounting/rolling_limits_tests/test_day_rolling_limits.py::TestDayRollingLimits::test_day_rolling_limit_output_tokens
-------------------------------- live log call ---------------------------------
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing SQLite backend for db: file:memdb_test_rolling_limits?mode=memory&cache=shared (connection_manager.py:22)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Creating SQLAlchemy engine for sqlite:///file:memdb_test_rolling_limits?mode=memory&cache=shared&uri=true (connection_manager.py:38)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing IN-MEMORY SQLite database (file:memdb_test_rolling_limits?mode=memory&cache=shared): creating schema using Base.metadata.create_all(). (connection_manager.py:48)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: In-memory database (file:memdb_test_rolling_limits?mode=memory&cache=shared) schema created. (connection_manager.py:51)
2023-01-01 00:00:00 [    INFO] llm_accounting.services.quota_service: QuotaService initialized. _denial_cache is empty: True (quota_service.py:24)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Closing SQLAlchemy connection for file:memdb_test_rolling_limits?mode=memory&cache=shared (connection_manager.py:146)
PASSED                                                                   [  0%]
tests/accounting/rolling_limits_tests/test_hour_rolling_limits.py::TestHourRollingLimits::test_hour_rolling_boundary_just_inside
-------------------------------- live log call ---------------------------------
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing SQLite backend for db: file:memdb_test_rolling_limits?mode=memory&cache=shared (connection_manager.py:22)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Creating SQLAlchemy engine for sqlite:///file:memdb_test_rolling_limits?mode=memory&cache=shared&uri=true (connection_manager.py:38)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing IN-MEMORY SQLite database (file:memdb_test_rolling_limits?mode=memory&cache=shared): creating schema using Base.metadata.create_all(). (connection_manager.py:48)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: In-memory database (file:memdb_test_rolling_limits?mode=memory&cache=shared) schema created. (connection_manager.py:51)
2023-01-01 00:00:00 [    INFO] llm_accounting.services.quota_service: QuotaService initialized. _denial_cache is empty: True (quota_service.py:24)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Closing SQLAlchemy connection for file:memdb_test_rolling_limits?mode=memory&cache=shared (connection_manager.py:146)
PASSED                                                                   [  0%]
tests/accounting/rolling_limits_tests/test_hour_rolling_limits.py::TestHourRollingLimits::test_hour_rolling_boundary_just_outside
-------------------------------- live log call ---------------------------------
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing SQLite backend for db: file:memdb_test_rolling_limits?mode=memory&cache=shared (connection_manager.py:22)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Creating SQLAlchemy engine for sqlite:///file:memdb_test_rolling_limits?mode=memory&cache=shared&uri=true (connection_manager.py:38)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing IN-MEMORY SQLite database (file:memdb_test_rolling_limits?mode=memory&cache=shared): creating schema using Base.metadata.create_all(). (connection_manager.py:48)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: In-memory database (file:memdb_test_rolling_limits?mode=memory&cache=shared) schema created. (connection_manager.py:51)
2023-01-01 00:00:00 [    INFO] llm_accounting.services.quota_service: QuotaService initialized. _denial_cache is empty: True (quota_service.py:24)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Closing SQLAlchemy connection for file:memdb_test_rolling_limits?mode=memory&cache=shared (connection_manager.py:146)
PASSED                                                                   [  1%]
tests/accounting/rolling_limits_tests/test_hour_rolling_limits.py::TestHourRollingLimits::test_no_usage_rolling_limit
-------------------------------- live log call ---------------------------------
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing SQLite backend for db: file:memdb_test_rolling_limits?mode=memory&cache=shared (connection_manager.py:22)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Creating SQLAlchemy engine for sqlite:///file:memdb_test_rolling_limits?mode=memory&cache=shared&uri=true (connection_manager.py:38)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing IN-MEMORY SQLite database (file:memdb_test_rolling_limits?mode=memory&cache=shared): creating schema using Base.metadata.create_all(). (connection_manager.py:48)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: In-memory database (file:memdb_test_rolling_limits?mode=memory&cache=shared) schema created. (connection_manager.py:51)
2023-01-01 00:00:00 [    INFO] llm_accounting.services.quota_service: QuotaService initialized. _denial_cache is empty: True (quota_service.py:24)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Closing SQLAlchemy connection for file:memdb_test_rolling_limits?mode=memory&cache=shared (connection_manager.py:146)
PASSED                                                                   [  1%]
tests/accounting/rolling_limits_tests/test_minute_rolling_limits.py::TestMinuteRollingLimits::test_minute_rolling_limit_input_tokens
-------------------------------- live log call ---------------------------------
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing SQLite backend for db: file:memdb_test_rolling_limits?mode=memory&cache=shared (connection_manager.py:22)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Creating SQLAlchemy engine for sqlite:///file:memdb_test_rolling_limits?mode=memory&cache=shared&uri=true (connection_manager.py:38)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing IN-MEMORY SQLite database (file:memdb_test_rolling_limits?mode=memory&cache=shared): creating schema using Base.metadata.create_all(). (connection_manager.py:48)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: In-memory database (file:memdb_test_rolling_limits?mode=memory&cache=shared) schema created. (connection_manager.py:51)
2023-01-01 00:00:00 [    INFO] llm_accounting.services.quota_service: QuotaService initialized. _denial_cache is empty: True (quota_service.py:24)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Closing SQLAlchemy connection for file:memdb_test_rolling_limits?mode=memory&cache=shared (connection_manager.py:146)
PASSED                                                                   [  2%]
tests/accounting/rolling_limits_tests/test_mixed_rolling_limits.py::TestMixedRollingLimits::test_mixed_fixed_and_rolling_limits_rolling_exceeded
-------------------------------- live log call ---------------------------------
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing SQLite backend for db: file:memdb_test_rolling_limits?mode=memory&cache=shared (connection_manager.py:22)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Creating SQLAlchemy engine for sqlite:///file:memdb_test_rolling_limits?mode=memory&cache=shared&uri=true (connection_manager.py:38)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing IN-MEMORY SQLite database (file:memdb_test_rolling_limits?mode=memory&cache=shared): creating schema using Base.metadata.create_all(). (connection_manager.py:48)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: In-memory database (file:memdb_test_rolling_limits?mode=memory&cache=shared) schema created. (connection_manager.py:51)
2023-01-01 00:00:00 [    INFO] llm_accounting.services.quota_service: QuotaService initialized. _denial_cache is empty: True (quota_service.py:24)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Closing SQLAlchemy connection for file:memdb_test_rolling_limits?mode=memory&cache=shared (connection_manager.py:146)
PASSED                                                                   [  2%]
tests/accounting/rolling_limits_tests/test_mixed_rolling_limits.py::TestMixedRollingLimits::test_multiple_rolling_limits_one_exceeded
-------------------------------- live log call ---------------------------------
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing SQLite backend for db: file:memdb_test_rolling_limits?mode=memory&cache=shared (connection_manager.py:22)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Creating SQLAlchemy engine for sqlite:///file:memdb_test_rolling_limits?mode=memory&cache=shared&uri=true (connection_manager.py:38)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing IN-MEMORY SQLite database (file:memdb_test_rolling_limits?mode=memory&cache=shared): creating schema using Base.metadata.create_all(). (connection_manager.py:48)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: In-memory database (file:memdb_test_rolling_limits?mode=memory&cache=shared) schema created. (connection_manager.py:51)
2023-01-01 00:00:00 [    INFO] llm_accounting.services.quota_service: QuotaService initialized. _denial_cache is empty: True (quota_service.py:24)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Closing SQLAlchemy connection for file:memdb_test_rolling_limits?mode=memory&cache=shared (connection_manager.py:146)
PASSED                                                                   [  3%]
tests/accounting/rolling_limits_tests/test_month_rolling_limits.py::TestMonthRollingLimits::test_month_rolling_limit_requests
-------------------------------- live log call ---------------------------------
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing SQLite backend for db: file:memdb_test_rolling_limits?mode=memory&cache=shared (connection_manager.py:22)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Creating SQLAlchemy engine for sqlite:///file:memdb_test_rolling_limits?mode=memory&cache=shared&uri=true (connection_manager.py:38)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing IN-MEMORY SQLite database (file:memdb_test_rolling_limits?mode=memory&cache=shared): creating schema using Base.metadata.create_all(). (connection_manager.py:48)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: In-memory database (file:memdb_test_rolling_limits?mode=memory&cache=shared) schema created. (connection_manager.py:51)
2023-01-01 00:00:00 [    INFO] llm_accounting.services.quota_service: QuotaService initialized. _denial_cache is empty: True (quota_service.py:24)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Closing SQLAlchemy connection for file:memdb_test_rolling_limits?mode=memory&cache=shared (connection_manager.py:146)
PASSED                                                                   [  3%]
tests/accounting/rolling_limits_tests/test_second_rolling_limits.py::TestSecondRollingLimits::test_basic_second_rolling_limit_exceed_limit
-------------------------------- live log call ---------------------------------
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing SQLite backend for db: file:memdb_test_rolling_limits?mode=memory&cache=shared (connection_manager.py:22)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Creating SQLAlchemy engine for sqlite:///file:memdb_test_rolling_limits?mode=memory&cache=shared&uri=true (connection_manager.py:38)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing IN-MEMORY SQLite database (file:memdb_test_rolling_limits?mode=memory&cache=shared): creating schema using Base.metadata.create_all(). (connection_manager.py:48)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: In-memory database (file:memdb_test_rolling_limits?mode=memory&cache=shared) schema created. (connection_manager.py:51)
2023-01-01 00:00:00 [    INFO] llm_accounting.services.quota_service: QuotaService initialized. _denial_cache is empty: True (quota_service.py:24)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Closing SQLAlchemy connection for file:memdb_test_rolling_limits?mode=memory&cache=shared (connection_manager.py:146)
PASSED                                                                   [  4%]
tests/accounting/rolling_limits_tests/test_second_rolling_limits.py::TestSecondRollingLimits::test_basic_second_rolling_limit_within_limit
-------------------------------- live log call ---------------------------------
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing SQLite backend for db: file:memdb_test_rolling_limits?mode=memory&cache=shared (connection_manager.py:22)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Creating SQLAlchemy engine for sqlite:///file:memdb_test_rolling_limits?mode=memory&cache=shared&uri=true (connection_manager.py:38)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing IN-MEMORY SQLite database (file:memdb_test_rolling_limits?mode=memory&cache=shared): creating schema using Base.metadata.create_all(). (connection_manager.py:48)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: In-memory database (file:memdb_test_rolling_limits?mode=memory&cache=shared) schema created. (connection_manager.py:51)
2023-01-01 00:00:00 [    INFO] llm_accounting.services.quota_service: QuotaService initialized. _denial_cache is empty: True (quota_service.py:24)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Closing SQLAlchemy connection for file:memdb_test_rolling_limits?mode=memory&cache=shared (connection_manager.py:146)
PASSED                                                                   [  4%]
tests/accounting/rolling_limits_tests/test_second_rolling_limits.py::TestSecondRollingLimits::test_second_rolling_limit_usage_outside_window
-------------------------------- live log call ---------------------------------
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing SQLite backend for db: file:memdb_test_rolling_limits?mode=memory&cache=shared (connection_manager.py:22)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Creating SQLAlchemy engine for sqlite:///file:memdb_test_rolling_limits?mode=memory&cache=shared&uri=true (connection_manager.py:38)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing IN-MEMORY SQLite database (file:memdb_test_rolling_limits?mode=memory&cache=shared): creating schema using Base.metadata.create_all(). (connection_manager.py:48)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: In-memory database (file:memdb_test_rolling_limits?mode=memory&cache=shared) schema created. (connection_manager.py:51)
2023-01-01 00:00:00 [    INFO] llm_accounting.services.quota_service: QuotaService initialized. _denial_cache is empty: True (quota_service.py:24)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Closing SQLAlchemy connection for file:memdb_test_rolling_limits?mode=memory&cache=shared (connection_manager.py:146)
PASSED                                                                   [  4%]
tests/accounting/rolling_limits_tests/test_week_rolling_limits.py::TestWeekRollingLimits::test_week_rolling_limit_cost
-------------------------------- live log call ---------------------------------
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing SQLite backend for db: file:memdb_test_rolling_limits?mode=memory&cache=shared (connection_manager.py:22)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Creating SQLAlchemy engine for sqlite:///file:memdb_test_rolling_limits?mode=memory&cache=shared&uri=true (connection_manager.py:38)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing IN-MEMORY SQLite database (file:memdb_test_rolling_limits?mode=memory&cache=shared): creating schema using Base.metadata.create_all(). (connection_manager.py:48)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: In-memory database (file:memdb_test_rolling_limits?mode=memory&cache=shared) schema created. (connection_manager.py:51)
2023-01-01 00:00:00 [    INFO] llm_accounting.services.quota_service: QuotaService initialized. _denial_cache is empty: True (quota_service.py:24)
2023-01-01 00:00:00 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Closing SQLAlchemy connection for file:memdb_test_rolling_limits?mode=memory&cache=shared (connection_manager.py:146)
PASSED                                                                   [  5%]
tests/accounting/test_account_model_limits.py::test_account_model_requests_per_minute
-------------------------------- live log setup --------------------------------
2025-06-08 17:15:29 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing SQLite backend for db: /tmp/pytest-of-swebot/pytest-20/test_account_model_requests_pe0/test_accounting.sqlite (connection_manager.py:22)
2025-06-08 17:15:29 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Creating SQLAlchemy engine for sqlite:////tmp/pytest-of-swebot/pytest-20/test_account_model_requests_pe0/test_accounting.sqlite (connection_manager.py:38)
2025-06-08 17:15:29 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: Initializing ON-DISK SQLite database (/tmp/pytest-of-swebot/pytest-20/test_account_model_requests_pe0/test_accounting.sqlite): using Alembic migrations. (connection_manager.py:53)
2025-06-08 17:15:29 [    INFO] llm_accounting.backends.sqlite_backend_parts.connection_manager: On-disk database /tmp/pytest-of-swebot/pytest-20/test_account_model_requests_pe0/test_accounting.sqlite is new. Running migrations and stamping with head revision. (connection_manager.py:73)
2025-06-08 17:15:29 [    INFO] llm_accounting.db_migrations.migrations: Attempting database migrations for URL: sqlite:////tmp/pytest-of-swebot/pytest-20/test_account_model_requests_pe0/test_accounting.sqlite (db_migrations.py:60)
FAILED                                                                   [  5%]
tests/accounting/test_account_model_limits.py::test_account_model_requests_per_day FAILED [  6%]
tests/accounting/test_account_model_limits.py::test_account_model_completion_tokens_per_minute FAILED [  6%]
tests/accounting/test_account_model_limits.py::test_account_model_completion_tokens_per_day FAILED [  7%]
tests/accounting/test_account_model_limits.py::test_account_total_requests_per_minute PASSED [  7%]
tests/accounting/test_comprehensive_limits.py::test_comprehensive_limit_scenarios FAILED [  8%]
tests/accounting/test_global_limits.py::test_global_limit PASSED         [  8%]
tests/accounting/test_model_limits.py::test_model_limit_priority PASSED  [  8%]
tests/accounting/test_multi_dimensional_quota.py::test_global_limit_overrides_user_limit PASSED [  9%]
tests/accounting/test_multi_dimensional_quota.py::test_user_limit_triggered_before_global PASSED [  9%]
tests/accounting/test_multi_dimensional_quota.py::test_model_and_project_limits_first_triggered PASSED [ 10%]
tests/accounting/test_multi_dimensional_quota.py::test_denial_cache_ttl_behavior PASSED [ 10%]
tests/accounting/test_multiple_limit_types.py::test_multiple_limit_types PASSED [ 11%]
tests/accounting/test_rolling_limits.py::TestRollingLimits::test_float_comparison_sanity_check PASSED [ 11%]
tests/accounting/test_rolling_limits.py::TestRollingLimits::test_placeholder PASSED [ 12%]
tests/accounting/test_user_caller_limits.py::test_user_caller_combination PASSED [ 12%]
tests/api_compatibility/test_audit_logger_api.py::TestAuditLoggerAPI::test_audit_logger_api_methods_exist PASSED [ 12%]
tests/api_compatibility/test_audit_logger_api.py::TestAuditLoggerAPI::test_get_entries_delegates_to_backend PASSED [ 13%]
tests/api_compatibility/test_audit_logger_api.py::TestAuditLoggerAPI::test_log_event_delegates_to_backend PASSED [ 13%]
tests/api_compatibility/test_audit_logger_api.py::TestAuditLoggerAPI::test_log_prompt_delegates_to_backend PASSED [ 14%]
tests/api_compatibility/test_audit_logger_api.py::TestAuditLoggerAPI::test_log_response_delegates_to_backend PASSED [ 14%]
tests/api_compatibility/test_llm_accounting_api.py::TestLLMAccountingAPI::test_delete_usage_limit_calls_backend PASSED [ 15%]
tests/api_compatibility/test_llm_accounting_api.py::TestLLMAccountingAPI::test_get_usage_limits_returns_list_of_usage_limit_data_from_backend PASSED [ 15%]
tests/api_compatibility/test_llm_accounting_api.py::TestLLMAccountingAPI::test_llm_accounting_api_methods_and_properties_exist PASSED [ 16%]
tests/api_compatibility/test_llm_accounting_api.py::TestLLMAccountingAPI::test_set_usage_limit_passes_usage_limit_data_to_backend PASSED [ 16%]
tests/backends/postgresql_backend_tests/test_postgresql_audit_log.py::TestPostgreSQLAuditLog::test_get_audit_log_entries_delegates_to_query_executor SKIPPED [ 16%]
tests/backends/postgresql_backend_tests/test_postgresql_audit_log.py::TestPostgreSQLAuditLog::test_initialize_audit_log_schema_method_ensures_connection SKIPPED [ 17%]
tests/backends/postgresql_backend_tests/test_postgresql_audit_log.py::TestPostgreSQLAuditLog::test_initialize_creates_audit_log_table SKIPPED [ 17%]
tests/backends/postgresql_backend_tests/test_postgresql_audit_log.py::TestPostgreSQLAuditLog::test_log_audit_event_delegates_and_manages_transaction SKIPPED [ 18%]
tests/backends/postgresql_backend_tests/test_postgresql_init_and_connection.py::TestPostgreSQLInitAndConnection::test_close_connection SKIPPED [ 18%]
tests/backends/postgresql_backend_tests/test_postgresql_init_and_connection.py::TestPostgreSQLInitAndConnection::test_init_success SKIPPED [ 19%]
tests/backends/postgresql_backend_tests/test_postgresql_init_and_connection.py::TestPostgreSQLInitAndConnection::test_initialize_connection_error SKIPPED [ 19%]
tests/backends/postgresql_backend_tests/test_postgresql_init_and_connection.py::TestPostgreSQLInitAndConnection::test_initialize_success SKIPPED [ 20%]
tests/backends/postgresql_backend_tests/test_postgresql_migrations_cache.py::TestPostgreSQLMigrationsCache::test_existing_db_cache_for_different_connection_string PASSED [ 20%]
tests/backends/postgresql_backend_tests/test_postgresql_migrations_cache.py::TestPostgreSQLMigrationsCache::test_existing_db_cache_missing_runs_migrations PASSED [ 20%]
tests/backends/postgresql_backend_tests/test_postgresql_migrations_cache.py::TestPostgreSQLMigrationsCache::test_existing_db_cache_outdated_runs_migrations PASSED [ 21%]
tests/backends/postgresql_backend_tests/test_postgresql_migrations_cache.py::TestPostgreSQLMigrationsCache::test_existing_db_cache_up_to_date_skips_migrations PASSED [ 21%]
tests/backends/postgresql_backend_tests/test_postgresql_migrations_cache.py::TestPostgreSQLMigrationsCache::test_existing_db_migrated_but_model_table_missing_runs_create_all PASSED [ 22%]
tests/backends/postgresql_backend_tests/test_postgresql_migrations_cache.py::TestPostgreSQLMigrationsCache::test_new_database_creates_schema_stamps_and_caches PASSED [ 22%]
tests/backends/postgresql_backend_tests/test_postgresql_query_delegation.py::TestPostgreSQLQueryDelegation::test_get_model_stats_delegates_to_query_executor SKIPPED [ 23%]
tests/backends/postgresql_backend_tests/test_postgresql_query_delegation.py::TestPostgreSQLQueryDelegation::test_get_period_stats_delegates_to_query_executor SKIPPED [ 23%]
tests/backends/postgresql_backend_tests/test_postgresql_query_execution.py::TestPostgreSQLQueryExecution::test_execute_query_non_select_error SKIPPED [ 24%]
tests/backends/postgresql_backend_tests/test_postgresql_query_execution.py::TestPostgreSQLQueryExecution::test_execute_query_success SKIPPED [ 24%]
tests/backends/postgresql_backend_tests/test_postgresql_quota_accounting.py::TestPostgreSQLQuotaAccounting::test_get_accounting_entries_for_quota_db_error SKIPPED [ 24%]
tests/backends/postgresql_backend_tests/test_postgresql_quota_accounting.py::TestPostgreSQLQuotaAccounting::test_get_accounting_entries_for_quota_invalid_type SKIPPED [ 25%]
tests/backends/postgresql_backend_tests/test_postgresql_quota_accounting.py::TestPostgreSQLQuotaAccounting::test_get_accounting_entries_for_quota_no_data SKIPPED [ 25%]
tests/backends/postgresql_backend_tests/test_postgresql_quota_accounting.py::TestPostgreSQLQuotaAccounting::test_get_accounting_entries_for_quota_success SKIPPED [ 26%]
tests/backends/postgresql_backend_tests/test_postgresql_usage_insertion.py::TestPostgreSQLUsageInsertion::test_insert_usage_success SKIPPED [ 26%]
tests/backends/postgresql_backend_tests/test_postgresql_usage_limits.py::TestPostgreSQLUsageLimits::test_delete_usage_limit_success SKIPPED [ 27%]
tests/backends/postgresql_backend_tests/test_postgresql_usage_limits.py::TestPostgreSQLUsageLimits::test_get_usage_limits_uses_limit_manager_and_returns_usage_limit_data SKIPPED [ 27%]
tests/backends/postgresql_backend_tests/test_postgresql_usage_limits.py::TestPostgreSQLUsageLimits::test_insert_usage_limit_uses_limit_manager_with_usage_limit_data SKIPPED [ 28%]
tests/backends/postgresql_backend_tests/test_postgresql_usage_limits.py::TestPostgreSQLUsageLimits::test_postgresql_specific_get_usage_limit_delegates_to_limit_manager SKIPPED [ 28%]
tests/backends/postgresql_backend_tests/test_postgresql_usage_limits.py::TestPostgreSQLUsageLimits::test_postgresql_specific_set_usage_limit_delegates_to_query_executor SKIPPED [ 28%]
tests/backends/sqlite_backend_tests/test_sqlite_audit_log.py::TestSQLiteAuditLog::test_audit_log_table_creation PASSED [ 29%]
tests/backends/sqlite_backend_tests/test_sqlite_audit_log.py::TestSQLiteAuditLog::test_log_single_audit_event PASSED [ 29%]
tests/backends/sqlite_backend_tests/test_sqlite_audit_log.py::TestSQLiteAuditLog::test_log_audit_event_minimal_fields PASSED [ 30%]
tests/backends/sqlite_backend_tests/test_sqlite_audit_log.py::TestSQLiteAuditLog::test_get_all_audit_logs PASSED [ 30%]
tests/backends/sqlite_backend_tests/test_sqlite_audit_log.py::TestSQLiteAuditLog::test_get_audit_logs_with_date_filters PASSED [ 31%]
tests/backends/sqlite_backend_tests/test_sqlite_audit_log.py::TestSQLiteAuditLog::test_get_audit_logs_with_app_name_filter PASSED [ 31%]
tests/backends/sqlite_backend_tests/test_sqlite_audit_log.py::TestSQLiteAuditLog::test_get_audit_logs_with_user_name_filter PASSED [ 32%]
tests/backends/sqlite_backend_tests/test_sqlite_audit_log.py::TestSQLiteAuditLog::test_get_audit_logs_with_project_filter PASSED [ 32%]
tests/backends/sqlite_backend_tests/test_sqlite_audit_log.py::TestSQLiteAuditLog::test_get_audit_logs_with_log_type_filter PASSED [ 32%]
tests/backends/sqlite_backend_tests/test_sqlite_audit_log.py::TestSQLiteAuditLog::test_get_audit_logs_with_limit PASSED [ 33%]
tests/backends/sqlite_backend_tests/test_sqlite_audit_log.py::TestSQLiteAuditLog::test_get_audit_logs_with_combined_filters PASSED [ 33%]
tests/backends/sqlite_backend_tests/test_sqlite_audit_log.py::TestSQLiteAuditLog::test_get_audit_logs_empty_result PASSED [ 34%]
tests/backends/sqlite_backend_tests/test_sqlite_audit_log.py::TestSQLiteAuditLog::test_get_audit_logs_order_by_timestamp PASSED [ 34%]
tests/backends/sqlite_backend_tests/test_sqlite_init_and_usage.py::test_initialize PASSED [ 35%]
tests/backends/sqlite_backend_tests/test_sqlite_init_and_usage.py::test_insert_usage PASSED [ 35%]
tests/backends/sqlite_backend_tests/test_sqlite_init_and_usage.py::test_insert_usage_with_project PASSED [ 36%]
tests/backends/sqlite_backend_tests/test_sqlite_init_and_usage.py::test_tail_retrieves_project PASSED [ 36%]
tests/backends/sqlite_backend_tests/test_sqlite_init_and_usage.py::test_execute_query_filter_by_project PASSED [ 36%]
tests/backends/sqlite_backend_tests/test_sqlite_migrations_cache.py::TestSQLiteMigrationCache::test_existing_db_cache_missing PASSED [ 37%]
tests/backends/sqlite_backend_tests/test_sqlite_migrations_cache.py::TestSQLiteMigrationCache::test_existing_db_cache_outdated PASSED [ 37%]
tests/backends/sqlite_backend_tests/test_sqlite_migrations_cache.py::TestSQLiteMigrationCache::test_existing_db_cache_up_to_date PASSED [ 38%]
tests/backends/sqlite_backend_tests/test_sqlite_migrations_cache.py::TestSQLiteMigrationCache::test_in_memory_database PASSED [ 38%]
tests/backends/sqlite_backend_tests/test_sqlite_migrations_cache.py::TestSQLiteMigrationCache::test_new_database_creates_schema_stamps_and_caches PASSED [ 39%]
tests/backends/sqlite_backend_tests/test_sqlite_stats_and_purge.py::test_get_period_stats PASSED [ 39%]
tests/backends/sqlite_backend_tests/test_sqlite_stats_and_purge.py::test_get_model_stats PASSED [ 40%]
tests/backends/sqlite_backend_tests/test_sqlite_stats_and_purge.py::test_get_model_rankings PASSED [ 40%]
tests/backends/sqlite_backend_tests/test_sqlite_stats_and_purge.py::test_purge PASSED [ 40%]
tests/backends/sqlite_backend_tests/test_sqlite_stats_and_purge.py::test_purge_empty_database PASSED [ 41%]
tests/backends/sqlite_backend_tests/test_sqlite_usage_limits.py::test_insert_project_scope_limit PASSED [ 41%]
tests/backends/sqlite_backend_tests/test_sqlite_usage_limits.py::test_get_usage_limits_filter_by_project_scope PASSED [ 42%]
tests/backends/sqlite_backend_tests/test_sqlite_usage_limits.py::test_get_accounting_entries_for_quota_with_project_filter PASSED [ 42%]
tests/backends/sqlite_backend_tests/test_sqlite_usage_limits.py::test_insert_and_get_usage_limits PASSED [ 43%]
tests/backends/sqlite_backend_tests/test_sqlite_usage_limits.py::test_get_usage_limits_with_filters PASSED [ 43%]
tests/backends/sqlite_backend_tests/test_sqlite_usage_limits.py::test_delete_usage_limit PASSED [ 44%]
tests/backends/sqlite_backend_tests/test_sqlite_usage_limits.py::test_datetime_precision_and_timezone_handling PASSED [ 44%]
tests/backends/test_base.py::test_backend_interface PASSED               [ 44%]
tests/backends/test_base.py::test_backend_abstract_methods PASSED        [ 45%]
tests/backends/test_csv_backend.py::TestCSVBackendInitialization::test_initialization_default_dir PASSED [ 45%]
tests/backends/test_csv_backend.py::TestCSVBackendInitialization::test_initialization_custom_dir PASSED [ 46%]
tests/backends/test_csv_backend.py::TestCSVBackendInitialization::test_data_dir_creation PASSED [ 46%]
tests/backends/test_csv_backend.py::TestCSVBackendInitialization::test_initialization_existing_files PASSED [ 47%]
tests/backends/test_csv_backend.py::TestCSVPurge::test_purge_clears_data_keeps_headers PASSED [ 47%]
tests/backends/test_csv_backend.py::TestAccountingEntries::test_insert_and_tail_single_entry PASSED [ 48%]
tests/backends/test_csv_backend.py::TestUsageLimits::test_insert_get_delete_usage_limit PASSED [ 48%]
tests/backends/test_csv_backend.py::TestAuditLog::test_insert_get_audit_log_entry PASSED [ 48%]
tests/backends/test_csv_backend.py::TestPeriodStats::test_get_period_stats_aggregation PASSED [ 49%]
tests/backends/test_csv_backend.py::TestFileHandlingAndEdgeCases::test_missing_files_recreated_on_operation PASSED [ 49%]
tests/backends/test_csv_backend.py::test_handling_io_error_on_init_standalone PASSED [ 50%]
tests/backends/test_usage_models.py::test_usage_entry_creation PASSED    [ 50%]
tests/backends/test_usage_models.py::test_usage_stats_creation PASSED    [ 51%]
tests/cli/test_cli_limits_project.py::test_cli_limits_set_project_scope_success PASSED [ 51%]
tests/cli/test_cli_limits_project.py::test_cli_limits_set_project_scope_missing_project_name PASSED [ 52%]
tests/cli/test_cli_limits_project.py::test_cli_limits_list_with_project_filters PASSED [ 52%]
tests/cli/test_cli_limits_project.py::test_cli_limits_delete_project_limit PASSED [ 52%]
tests/cli/test_cli_log_event.py::test_log_event_basic PASSED             [ 53%]
tests/cli/test_cli_log_event.py::test_log_event_persists_data PASSED     [ 53%]
tests/cli/test_cli_log_event.py::test_log_event_with_timestamp PASSED    [ 54%]
tests/cli/test_cli_log_event.py::test_log_event_with_iso_timestamp_and_tz PASSED [ 54%]
tests/cli/test_cli_log_event.py::test_log_event_timestamp_parse_error PASSED [ 55%]
tests/cli/test_cli_purge.py::test_purge_with_confirmation PASSED         [ 55%]
tests/cli/test_cli_purge.py::test_purge_without_confirmation PASSED      [ 56%]
tests/cli/test_cli_purge.py::test_purge_with_yes_flag PASSED             [ 56%]
tests/cli/test_cli_purge.py::test_purge_with_yes_flag_long PASSED        [ 56%]
tests/cli/test_cli_stats.py::test_stats_no_period PASSED                 [ 57%]
tests/cli/test_cli_stats.py::test_stats_periods[period_args0-Daily Stats] PASSED [ 57%]
tests/cli/test_cli_stats.py::test_stats_periods[period_args1-Weekly Stats] PASSED [ 58%]
tests/cli/test_cli_stats.py::test_stats_periods[period_args2-Monthly Stats] PASSED [ 58%]
tests/cli/test_cli_stats.py::test_stats_periods[period_args3-Yearly Stats] PASSED [ 59%]
tests/cli/test_cli_stats.py::test_stats_custom_period PASSED             [ 59%]
tests/cli/test_cli_stats.py::test_custom_db_file_usage PASSED            [ 60%]
tests/cli/test_cli_stats.py::test_default_db_file_usage PASSED           [ 60%]
tests/cli/test_cli_stats.py::test_db_file_validation_error PASSED        [ 60%]
tests/cli/test_cli_stats.py::test_db_file_permission_error PASSED        [ 61%]
tests/cli/test_cli_tail.py::test_tail_default PASSED                     [ 61%]
tests/cli/test_cli_tail.py::test_tail_custom_number PASSED               [ 62%]
tests/cli/test_cli_tail.py::test_tail_empty PASSED                       [ 62%]
tests/cli/test_cli_track.py::test_track_usage PASSED                     [ 63%]
tests/cli/test_cli_track.py::test_track_usage_with_project PASSED        [ 63%]
tests/cli/test_cli_track.py::test_track_usage_with_timestamp PASSED      [ 64%]
tests/cli/test_cli_track.py::test_track_usage_with_caller_name PASSED    [ 64%]
tests/cli/test_cli_track.py::test_track_usage_with_username PASSED       [ 64%]
tests/cli/test_cli_track.py::test_track_usage_with_cached_tokens PASSED  [ 65%]
tests/cli/test_cli_track.py::test_track_usage_with_reasoning_tokens PASSED [ 65%]
tests/cli/test_cli_version.py::test_cli_version PASSED                   [ 66%]
tests/cli/test_select/select/test_aggregation.py::test_select_aggregation PASSED [ 66%]
tests/cli/test_select/select/test_basic_query.py::test_select_basic_query PASSED [ 67%]
tests/cli/test_select/select/test_no_results.py::test_select_no_results PASSED [ 67%]
tests/cli/test_select/select/test_non_select_query.py::test_select_non_select_query PASSED [ 68%]
tests/cli/test_select/select/test_output_formatting.py::test_select_output_formatting PASSED [ 68%]
tests/cli/test_select/select/test_syntax_error.py::test_select_syntax_error PASSED [ 68%]
tests/cli/test_select_project.py::test_select_no_project_filter_displays_project_column PASSED [ 69%]
tests/cli/test_select_project.py::test_select_filter_by_project_name PASSED [ 69%]
tests/cli/test_select_project.py::test_select_filter_by_project_null PASSED [ 70%]
tests/core/test_accounting_purge.py::test_purge PASSED                   [ 70%]
tests/core/test_accounting_stats.py::test_get_period_stats PASSED        [ 71%]
tests/core/test_accounting_stats.py::test_get_model_stats PASSED         [ 71%]
tests/core/test_accounting_stats.py::test_get_model_rankings PASSED      [ 72%]
tests/core/test_accounting_tracking.py::test_track_usage PASSED          [ 72%]
tests/core/test_accounting_tracking.py::test_tail PASSED                 [ 72%]
tests/core/test_accounting_tracking.py::test_tail_empty PASSED           [ 73%]
tests/core/test_accounting_tracking.py::test_tail_default_limit PASSED   [ 73%]
tests/core/test_accounting_tracking.py::test_track_usage_with_caller_and_user PASSED [ 74%]
tests/core/test_accounting_tracking.py::test_tail_with_caller_and_user PASSED [ 74%]
tests/core/test_accounting_validation.py::test_track_usage_empty_model PASSED [ 75%]
tests/core/test_accounting_validation.py::test_track_usage_none_model PASSED [ 75%]
tests/core/test_accounting_validation.py::test_usage_entry_empty_model PASSED [ 76%]
tests/core/test_accounting_validation.py::test_usage_entry_none_model PASSED [ 76%]
tests/core/test_accounting_validation.py::test_track_usage_without_timestamp PASSED [ 76%]
tests/core/test_accounting_validation.py::test_track_usage_with_timestamp PASSED [ 77%]
tests/core/test_accounting_validation.py::test_track_usage_with_token_details PASSED [ 77%]
tests/core/test_accounting_validation.py::test_track_usage_default_token_details PASSED [ 78%]
tests/core/test_output_silence.py::TestOutputSilence::test_audit_logger_silence PASSED [ 78%]
tests/core/test_output_silence.py::TestOutputSilence::test_llm_accounting_context_manager_silence PASSED [ 79%]
tests/core/test_output_silence.py::TestOutputSilence::test_mock_backend_operations_debug_silence PASSED [ 79%]
tests/core/test_output_silence.py::TestOutputSilence::test_quota_service_silence PASSED [ 80%]
tests/core/test_project_quota_service.py::test_project_limit_cost PASSED [ 80%]
tests/core/test_project_quota_service.py::test_project_limit_requests PASSED [ 80%]
tests/core/test_project_quota_service.py::test_project_limit_with_global_limit_cost PASSED [ 81%]
tests/core/test_project_quota_service.py::test_project_limit_with_model_limit FAILED [ 81%]
tests/core/test_project_quota_service.py::test_project_limit_with_no_specific_project_in_request PASSED [ 82%]
tests/core/test_project_quota_service.py::test_limit_message_for_project_scope FAILED [ 82%]
tests/core/test_quota_service.py::test_check_quota_no_limits PASSED      [ 83%]
tests/core/test_quota_service.py::test_check_quota_allowed_single_limit PASSED [ 83%]
tests/core/test_quota_service.py::test_check_quota_denied_single_limit PASSED [ 84%]
tests/core/test_quota_service.py::test_check_quota_multiple_limits_one_exceeded PASSED [ 84%]
tests/core/test_quota_service.py::test_check_quota_different_scopes_in_cache PASSED [ 84%]
tests/core/test_quota_service.py::test_check_quota_token_limits PASSED   [ 85%]
tests/core/test_quota_service.py::test_get_period_start_monthly PASSED   [ 85%]
tests/core/test_quota_service.py::test_get_period_start_daily PASSED     [ 86%]
tests/core/test_quota_service.py::test_get_period_start_hourly PASSED    [ 86%]
tests/core/test_quota_service.py::test_get_period_start_minute PASSED    [ 87%]
tests/core/test_quota_service.py::test_get_period_start_second PASSED    [ 87%]
tests/core/test_quota_service.py::test_get_period_start_weekly PASSED    [ 88%]
tests/core/test_quota_service.py::test_get_period_start_unsupported_interval PASSED [ 88%]
tests/core/test_quota_service.py::test_check_quota_enhanced_no_limits PASSED [ 88%]
tests/core/test_quota_service.py::test_check_quota_enhanced_allowed_single_limit PASSED [ 89%]
tests/core/test_quota_service.py::test_check_quota_enhanced_denied_single_limit PASSED [ 89%]
tests/core/test_quota_service.py::test_check_quota_enhanced_denied_retry_after_various_intervals[TimeInterval.SECOND-10-9.0-1.1-2024-01-01T00:00:05Z-2024-01-01T00:00:10Z] PASSED [ 90%]
tests/core/test_quota_service.py::test_check_quota_enhanced_denied_retry_after_various_intervals[TimeInterval.MINUTE-1-50.0-11.0-2024-01-01T00:00:30Z-2024-01-01T00:01:00Z] PASSED [ 90%]
tests/core/test_quota_service.py::test_check_quota_enhanced_denied_retry_after_various_intervals[TimeInterval.MINUTE-2-50.0-11.0-2024-01-01T00:00:30Z-2024-01-01T00:02:00Z] PASSED [ 91%]
tests/core/test_quota_service.py::test_check_quota_enhanced_denied_retry_after_various_intervals[TimeInterval.HOUR-1-50.0-11.0-2024-01-01T00:30:00Z-2024-01-01T01:00:00Z] PASSED [ 91%]
tests/core/test_quota_service.py::test_check_quota_enhanced_denied_retry_after_various_intervals[TimeInterval.DAY-1-20.0-5.0-2024-01-01T12:00:00Z-2024-01-02T00:00:00Z] PASSED [ 92%]
tests/core/test_quota_service.py::test_check_quota_enhanced_denied_retry_after_various_intervals[TimeInterval.SECOND_ROLLING-10-9.0-1.1-2024-01-01T00:00:10Z-2024-01-01T00:00:10Z] PASSED [ 92%]
tests/core/test_quota_service.py::test_check_quota_enhanced_denied_retry_after_various_intervals[TimeInterval.MINUTE_ROLLING-1-50.0-11.0-2024-01-01T00:01:00Z-2024-01-01T00:01:00Z] PASSED [ 92%]
tests/core/test_quota_service.py::test_check_quota_enhanced_denied_retry_after_various_intervals[TimeInterval.HOUR_ROLLING-1-50.0-11.0-2024-01-01T01:00:00Z-2024-01-01T01:00:00Z] PASSED [ 93%]
tests/core/test_quota_service.py::test_check_quota_enhanced_denied_retry_after_various_intervals[TimeInterval.MONTH_ROLLING-1-10.0-1.0-2024-01-15T10:00:00Z-2024-02-01T00:00:00Z] PASSED [ 93%]
tests/core/test_quota_service.py::test_check_quota_enhanced_denied_fixed_month_retry_after PASSED [ 94%]
tests/core/test_quota_service.py::test_check_quota_enhanced_denied_rolling_month_retry_after PASSED [ 94%]
tests/core/test_quota_service.py::test_check_quota_enhanced_denied_retry_after_zero_or_negative_becomes_zero PASSED [ 95%]
tests/core/test_quota_service.py::test_check_quota_enhanced_denial_cached PASSED [ 95%]
tests/core/test_quota_service.py::test_check_quota_enhanced_cache_expires PASSED [ 96%]
tests/test_audit_log.py::test_log_prompt PASSED                          [ 96%]
tests/test_audit_log.py::test_log_response PASSED                        [ 96%]
tests/test_audit_log.py::test_log_event_method PASSED                    [ 97%]
tests/test_audit_log.py::test_nullable_fields PASSED                     [ 97%]
tests/test_audit_log.py::test_get_entries PASSED                         [ 98%]
tests/test_migrations.py::test_sqlite_initial_migration_creates_schema PASSED [ 98%]
tests/test_migrations.py::test_sqlite_applies_new_migration_and_preserves_data PASSED [ 99%]
tests/test_migrations.py::test_postgresql_initial_migration_creates_schema SKIPPED [ 99%]
tests/test_migrations.py::test_postgresql_applies_new_migration_and_preserves_data SKIPPED [100%]

=================================== FAILURES ===================================
____________________ test_account_model_requests_per_minute ____________________

accounting_instance = <llm_accounting.LLMAccounting object at 0x7f7651d1e470>
sqlite_backend_for_accounting = <llm_accounting.backends.sqlite.SQLiteBackend object at 0x7f7651d1e110>

    def test_account_model_requests_per_minute(accounting_instance: LLMAccounting, sqlite_backend_for_accounting: SQLiteBackend):
        """Test requests per minute limit for a specific account and model."""
        username = "test_user_ab"
        model_name = "model_x"
        caller = "caller_rpm"

        global_limit = UsageLimitDTO(
            scope=LimitScope.GLOBAL.value, limit_type=LimitType.REQUESTS.value,
            max_value=100, interval_unit=TimeInterval.MINUTE.value, interval_value=1
        )
        account_model_limit = UsageLimitDTO(
            scope=LimitScope.USER.value,
            username=username,
            model=model_name,
            limit_type=LimitType.REQUESTS.value,
            max_value=3,
            interval_unit=TimeInterval.MINUTE.value,
            interval_value=1
        )
        sqlite_backend_for_accounting.insert_usage_limit(account_model_limit)
        sqlite_backend_for_accounting.insert_usage_limit(global_limit)
        accounting_instance.quota_service.refresh_limits_cache() # Refresh cache after inserting limits

        with freeze_time("2023-01-01 00:00:00", tz_offset=0) as freezer:
            for i in range(3):
                # Advance time by 1 second for each request to ensure distinct timestamps
                freezer.tick(delta=timedelta(seconds=1)) # Use tick for incremental advancement
                allowed, reason = accounting_instance.check_quota(
                    model=model_name, username=username, caller_name=caller, input_tokens=10, completion_tokens=10
                )
                assert allowed, f"Request {i+1}/3 for {model_name} by {username} should be allowed. Reason: {reason}"
                accounting_instance.track_usage(
                    model=model_name, username=username, caller_name=caller,
                    prompt_tokens=10, completion_tokens=10, cost=0.01, timestamp=datetime.now(timezone.utc)
                )

            # For the 4th request, ensure time is still within the same minute for the limit check
            freezer.tick(delta=timedelta(seconds=1)) # Use tick for incremental advancement
            allowed, message = accounting_instance.check_quota(
                model=model_name, username=username, caller_name=caller, input_tokens=10, completion_tokens=10
            )
            assert not allowed, f"4th request for {model_name} by {username} should be denied"
            assert message is not None, "Denial message should not be None"
>           assert f"USER (user: {username})" in message  # Adjusted order
E           AssertionError: assert 'USER (user: test_user_ab)' in 'USER (model: model_x, user: test_user_ab) limit: 3.00 requests per 1 minute exceeded. Current usage: 3.00, request: 1.00.'

tests/accounting/test_account_model_limits.py:72: AssertionError
---------------------------- Captured stderr setup -----------------------------
INFO:llm_accounting.backends.sqlite_backend_parts.connection_manager:Initializing SQLite backend for db: /tmp/pytest-of-swebot/pytest-20/test_account_model_requests_pe0/test_accounting.sqlite
INFO:llm_accounting.backends.sqlite_backend_parts.connection_manager:Creating SQLAlchemy engine for sqlite:////tmp/pytest-of-swebot/pytest-20/test_account_model_requests_pe0/test_accounting.sqlite
INFO:llm_accounting.backends.sqlite_backend_parts.connection_manager:Initializing ON-DISK SQLite database (/tmp/pytest-of-swebot/pytest-20/test_account_model_requests_pe0/test_accounting.sqlite): using Alembic migrations.
INFO:llm_accounting.backends.sqlite_backend_parts.connection_manager:On-disk database /tmp/pytest-of-swebot/pytest-20/test_account_model_requests_pe0/test_accounting.sqlite is new. Running migrations and stamping with head revision.
INFO:llm_accounting.db_migrations.migrations:Attempting database migrations for URL: sqlite:////tmp/pytest-of-swebot/pytest-20/test_account_model_requests_pe0/test_accounting.sqlite
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 82f27c891782, initial_tables
INFO  [alembic.runtime.migration] Running upgrade 82f27c891782 -> ba9718840e75, add_notes_to_accounting_entry
------------------------------ Captured log setup ------------------------------
INFO     llm_accounting.backends.sqlite_backend_parts.connection_manager:connection_manager.py:22 Initializing SQLite backend for db: /tmp/pytest-of-swebot/pytest-20/test_account_model_requests_pe0/test_accounting.sqlite
INFO     llm_accounting.backends.sqlite_backend_parts.connection_manager:connection_manager.py:38 Creating SQLAlchemy engine for sqlite:////tmp/pytest-of-swebot/pytest-20/test_account_model_requests_pe0/test_accounting.sqlite
INFO     llm_accounting.backends.sqlite_backend_parts.connection_manager:connection_manager.py:53 Initializing ON-DISK SQLite database (/tmp/pytest-of-swebot/pytest-20/test_account_model_requests_pe0/test_accounting.sqlite): using Alembic migrations.
INFO     llm_accounting.backends.sqlite_backend_parts.connection_manager:connection_manager.py:73 On-disk database /tmp/pytest-of-swebot/pytest-20/test_account_model_requests_pe0/test_accounting.sqlite is new. Running migrations and stamping with head revision.
INFO     llm_accounting.db_migrations.migrations:db_migrations.py:60 Attempting database migrations for URL: sqlite:////tmp/pytest-of-swebot/pytest-20/test_account_model_requests_pe0/test_accounting.sqlite
_____________________ test_account_model_requests_per_day ______________________

accounting_instance = <llm_accounting.LLMAccounting object at 0x7f7651c19690>
sqlite_backend_for_accounting = <llm_accounting.backends.sqlite.SQLiteBackend object at 0x7f7651c196c0>

    def test_account_model_requests_per_day(accounting_instance: LLMAccounting, sqlite_backend_for_accounting: SQLiteBackend):
        """Test requests per day limit for a specific account and model."""
        username = "test_user_cd"
        model_name = "model_y"
        caller = "caller_rpd"

        global_limit = UsageLimitDTO(
            scope=LimitScope.GLOBAL.value, limit_type=LimitType.REQUESTS.value,
            max_value=100, interval_unit=TimeInterval.DAY.value, interval_value=1
        )
        account_model_limit = UsageLimitDTO(
            scope=LimitScope.USER.value,
            username=username,
            model=model_name,
            limit_type=LimitType.REQUESTS.value,
            max_value=2,
            interval_unit=TimeInterval.DAY.value,
            interval_value=1
        )
        sqlite_backend_for_accounting.insert_usage_limit(account_model_limit)
        sqlite_backend_for_accounting.insert_usage_limit(global_limit)
        accounting_instance.quota_service.refresh_limits_cache() # Refresh cache after inserting limits

        with freeze_time("2023-01-01 00:00:00", tz_offset=0) as freezer:
            # Track 2 requests on the same day, but at different times
            freezer.tick(delta=timedelta(hours=10)) # 10:00 AM on Jan 1st
            allowed, reason = accounting_instance.check_quota(
                model=model_name, username=username, caller_name=caller, input_tokens=10, completion_tokens=10
            )
            assert allowed, f"Request 1/2 for {model_name} by {username} should be allowed. Reason: {reason}"
            accounting_instance.track_usage(
                model=model_name, username=username, caller_name=caller,
                prompt_tokens=10, completion_tokens=10, cost=0.01, timestamp=datetime.now(timezone.utc)
            )

            freezer.tick(delta=timedelta(hours=1)) # 11:00 AM on Jan 1st
            allowed, reason = accounting_instance.check_quota(
                model=model_name, username=username, caller_name=caller, input_tokens=10, completion_tokens=10
            )
            assert allowed, f"Request 2/2 for {model_name} by {username} should be allowed. Reason: {reason}"
            accounting_instance.track_usage(
                model=model_name, username=username, caller_name=caller,
                prompt_tokens=10, completion_tokens=10, cost=0.01, timestamp=datetime.now(timezone.utc)
            )

            # Attempt a 3rd request on the same day - should be denied
            freezer.tick(delta=timedelta(hours=1)) # 12:00 PM on Jan 1st
            allowed, message = accounting_instance.check_quota(
                model=model_name, username=username, caller_name=caller, input_tokens=10, completion_tokens=10
            )
            assert not allowed, f"3rd request for {model_name} by {username} should be denied"
            assert message is not None, "Denial message should not be None"
>           assert f"USER (user: {username})" in message  # Adjusted order
E           AssertionError: assert 'USER (user: test_user_cd)' in 'USER (model: model_y, user: test_user_cd) limit: 2.00 requests per 1 day exceeded. Current usage: 2.00, request: 1.00.'

tests/accounting/test_account_model_limits.py:141: AssertionError
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 82f27c891782, initial_tables
INFO  [alembic.runtime.migration] Running upgrade 82f27c891782 -> ba9718840e75, add_notes_to_accounting_entry
_______________ test_account_model_completion_tokens_per_minute ________________

accounting_instance = <llm_accounting.LLMAccounting object at 0x7f7651c188e0>
sqlite_backend_for_accounting = <llm_accounting.backends.sqlite.SQLiteBackend object at 0x7f7651c1bac0>

    def test_account_model_completion_tokens_per_minute(accounting_instance: LLMAccounting, sqlite_backend_for_accounting: SQLiteBackend):
        """Test completion tokens per minute limit for a specific account and model."""
        username = "test_user_ef"
        model_name = "model_z"
        caller = "caller_ctpm"

        global_limit = UsageLimitDTO(
            scope=LimitScope.GLOBAL.value, limit_type=LimitType.OUTPUT_TOKENS.value,
            max_value=5000, interval_unit=TimeInterval.MINUTE.value, interval_value=1
        )
        account_model_limit = UsageLimitDTO(
            scope=LimitScope.USER.value,
            username=username,
            model=model_name,
            limit_type=LimitType.OUTPUT_TOKENS.value,
            max_value=1000,
            interval_unit=TimeInterval.MINUTE.value,
            interval_value=1
        )
        sqlite_backend_for_accounting.insert_usage_limit(account_model_limit)
        sqlite_backend_for_accounting.insert_usage_limit(global_limit)
        accounting_instance.quota_service.refresh_limits_cache() # Refresh cache after inserting limits

        with freeze_time("2023-01-01 00:00:00", tz_offset=0) as freezer:
            # First request: 500 tokens
            freezer.tick(delta=timedelta(seconds=0)) # Start at 00:00:00
            allowed, reason = accounting_instance.check_quota(
                model=model_name, username=username, caller_name=caller, input_tokens=10, completion_tokens=500
            )
            assert allowed, f"Request 1 (500 tokens) for {model_name} by {username} should be allowed. Reason: {reason}"
            accounting_instance.track_usage(
                model=model_name, username=username, caller_name=caller,
                prompt_tokens=10, completion_tokens=500, cost=0.01, timestamp=datetime.now(timezone.utc)
            )

            # Second request: 500 tokens (total 1000)
            freezer.tick(delta=timedelta(seconds=1)) # 00:00:01
            allowed, reason = accounting_instance.check_quota(
                model=model_name, username=username, caller_name=caller, input_tokens=10, completion_tokens=500
            )
            assert allowed, f"Request 2 (500 tokens) for {model_name} by {username} should be allowed. Reason: {reason}"
            accounting_instance.track_usage(
                model=model_name, username=username, caller_name=caller,
                prompt_tokens=10, completion_tokens=500, cost=0.01, timestamp=datetime.now(timezone.utc)
            )

            # Third request: 1 token (total 1001 - should be denied)
            freezer.tick(delta=timedelta(seconds=1)) # 00:00:02
            allowed, message = accounting_instance.check_quota(
                model=model_name, username=username, caller_name=caller, input_tokens=10, completion_tokens=1
            )
            assert not allowed, f"Request 3 (1 token) for {model_name} by {username} should be denied"
            assert message is not None, "Denial message should not be None"
>           assert f"USER (user: {username})" in message  # Adjusted order
E           AssertionError: assert 'USER (user: test_user_ef)' in 'USER (model: model_z, user: test_user_ef) limit: 1000.00 output_tokens per 1 minute exceeded. Current usage: 1000.00, request: 1.00.'

tests/accounting/test_account_model_limits.py:209: AssertionError
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 82f27c891782, initial_tables
INFO  [alembic.runtime.migration] Running upgrade 82f27c891782 -> ba9718840e75, add_notes_to_accounting_entry
_________________ test_account_model_completion_tokens_per_day _________________

accounting_instance = <llm_accounting.LLMAccounting object at 0x7f76521bc7c0>
sqlite_backend_for_accounting = <llm_accounting.backends.sqlite.SQLiteBackend object at 0x7f76521be2f0>

    def test_account_model_completion_tokens_per_day(accounting_instance: LLMAccounting, sqlite_backend_for_accounting: SQLiteBackend):
        """Test completion tokens per day limit for a specific account and model."""
        username = "test_user_gh"
        model_name = "model_a"
        caller = "caller_ctpd"

        global_limit = UsageLimitDTO(
            scope=LimitScope.GLOBAL.value, limit_type=LimitType.OUTPUT_TOKENS.value,
            max_value=5000, interval_unit=TimeInterval.DAY.value, interval_value=1
        )
        account_model_limit = UsageLimitDTO(
            scope=LimitScope.USER.value,
            username=username,
            model=model_name,
            limit_type=LimitType.OUTPUT_TOKENS.value,
            max_value=200,
            interval_unit=TimeInterval.DAY.value,
            interval_value=1
        )
        sqlite_backend_for_accounting.insert_usage_limit(account_model_limit)
        sqlite_backend_for_accounting.insert_usage_limit(global_limit)
        accounting_instance.quota_service.refresh_limits_cache() # Refresh cache after inserting limits

        with freeze_time("2023-01-01 00:00:00", tz_offset=0) as freezer:
            # First request: 150 tokens
            freezer.tick(delta=timedelta(seconds=0)) # Start at 00:00:00
            allowed, reason = accounting_instance.check_quota(
                model=model_name, username=username, caller_name=caller, input_tokens=10, completion_tokens=150
            )
            assert allowed, f"Request 1 (150 tokens) for {model_name} by {username} should be allowed. Reason: {reason}"
            accounting_instance.track_usage(
                model=model_name, username=username, caller_name=caller,
                prompt_tokens=10, completion_tokens=150, cost=0.01, timestamp=datetime.now(timezone.utc)
            )

            # Second request: 51 tokens (total 201 - should be denied)
            freezer.tick(delta=timedelta(seconds=1)) # 00:00:01
            allowed, message = accounting_instance.check_quota(
                model=model_name, username=username, caller_name=caller, input_tokens=10, completion_tokens=51
            )
            assert not allowed, f"Request 2 (51 tokens) for {model_name} by {username} should be denied"
            assert message is not None, "Denial message should not be None"
>           assert f"USER (user: {username})" in message # Adjusted order
E           AssertionError: assert 'USER (user: test_user_gh)' in 'USER (model: model_a, user: test_user_gh) limit: 200.00 output_tokens per 1 day exceeded. Current usage: 150.00, request: 51.00.'

tests/accounting/test_account_model_limits.py:266: AssertionError
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 82f27c891782, initial_tables
INFO  [alembic.runtime.migration] Running upgrade 82f27c891782 -> ba9718840e75, add_notes_to_accounting_entry
______________________ test_comprehensive_limit_scenarios ______________________

accounting_instance = <llm_accounting.LLMAccounting object at 0x7f7651c0e710>
sqlite_backend_for_accounting = <llm_accounting.backends.sqlite.SQLiteBackend object at 0x7f7651c0e1a0>

    @freeze_time("2023-01-01 00:00:00", tz_offset=0)
    def test_comprehensive_limit_scenarios(accounting_instance: LLMAccounting, sqlite_backend_for_accounting: SQLiteBackend):
        from datetime import timedelta # Ensure timedelta is in scope
        backend = sqlite_backend_for_accounting # alias for convenience

        # 1. Define and Insert Limits
        limits_to_insert = [
            # GL1: Global Daily Requests
            UsageLimitDTO(scope=LimitScope.GLOBAL.value, limit_type=LimitType.REQUESTS.value, max_value=100, interval_unit=TimeInterval.DAY.value, interval_value=1, project_name=None, model=None, username=None, caller_name=None),
            # UM1: Tokens/User-Model/Min
            UsageLimitDTO(scope=LimitScope.USER.value, username="user1", model="gpt-4", limit_type=LimitType.OUTPUT_TOKENS.value, max_value=1000, interval_unit=TimeInterval.MINUTE_ROLLING.value, interval_value=1, project_name=None, caller_name=None),
            # UM2: Calls/User-Model/Min (Increased to avoid hitting before token limit in Scenario 2, original value was 5)
            UsageLimitDTO(scope=LimitScope.USER.value, username="user1", model="gpt-4", limit_type=LimitType.REQUESTS.value, max_value=1000, interval_unit=TimeInterval.MINUTE_ROLLING.value, interval_value=1, project_name=None, caller_name=None),
            # New limit for Scenario 1: Requests/User-Model/Min for a dedicated test user
            UsageLimitDTO(scope=LimitScope.USER.value, username="user_requests_test", model="test-model", limit_type=LimitType.REQUESTS.value, max_value=5, interval_unit=TimeInterval.MINUTE_ROLLING.value, interval_value=1, project_name=None, caller_name=None),
            # UM3: Tokens/User-Model/Day
            UsageLimitDTO(scope=LimitScope.USER.value, username="user1", model="gpt-4", limit_type=LimitType.OUTPUT_TOKENS.value, max_value=10000, interval_unit=TimeInterval.DAY.value, interval_value=1, project_name=None, caller_name=None),
            # UM4: Calls/User-Model/Day
            UsageLimitDTO(scope=LimitScope.USER.value, username="user1", model="gpt-4", limit_type=LimitType.REQUESTS.value, max_value=20, interval_unit=TimeInterval.DAY.value, interval_value=1, project_name=None, caller_name=None),
            # UH1: Cost/User/Hour
            UsageLimitDTO(scope=LimitScope.USER.value, username="user1", limit_type=LimitType.COST.value, max_value=2.00, interval_unit=TimeInterval.HOUR.value, interval_value=1, project_name=None, model=None, caller_name=None),
            # UD1: Cost/User/Day
            UsageLimitDTO(scope=LimitScope.USER.value, username="user1", limit_type=LimitType.COST.value, max_value=10.00, interval_unit=TimeInterval.DAY.value, interval_value=1, project_name=None, model=None, caller_name=None),
            # User2 specific limit
            UsageLimitDTO(scope=LimitScope.USER.value, username="user2", model="gpt-3.5-turbo", limit_type=LimitType.REQUESTS.value, max_value=10, interval_unit=TimeInterval.DAY.value, interval_value=1, project_name=None, caller_name=None),
        ]

        for limit in limits_to_insert:
            backend.insert_usage_limit(limit)

        # 2. Force Refresh Cache
        accounting_instance.quota_service.refresh_limits_cache()

        # --- Scenario 1: User-Model Minute Requests Limit (New dedicated limit) ---
        with freeze_time("2023-01-01 00:00:00", tz_offset=0) as freezer: # Initial time
            # Test the new 'user_requests_test' limit (max_value=5 requests/min)
            for i in range(5): # 5 calls
                current_time = datetime(2023, 1, 1, 0, 0, i, tzinfo=timezone.utc) # Advance time by seconds
                freezer.move_to(current_time) # Move the frozen time
                allowed, message = make_call_and_track(
                    accounting_instance, "test-model", "user_requests_test", input_tokens=1, completion_tokens=1, cost=0.0001
                )
                assert allowed, f"Scenario 1: Call {i+1}/5 for user_requests_test should be allowed. Message: {message}"

            # 6th call should violate the new requests limit
            # Advance time for the 6th call as well
            current_time = datetime(2023, 1, 1, 0, 0, 5, tzinfo=timezone.utc) # 5 seconds after start
            freezer.move_to(current_time)
            allowed, message = make_call_and_track(accounting_instance, "test-model", "user_requests_test", 1, 1, 0.0001)
            assert not allowed, "Scenario 1: 6th call for user_requests_test should be denied by its requests/min limit"
>           assert "USER (user: user_requests_test) limit: 5.00 requests per 1 minute_rolling exceeded. Current usage: 5.00, request: 1.00." in message, f"Scenario 1 (Requests/Min): Denial message mismatch: {message}"
E           AssertionError: Scenario 1 (Requests/Min): Denial message mismatch: USER (model: test-model, user: user_requests_test) limit: 5.00 requests per 1 minute_rolling exceeded. Current usage: 5.00, request: 1.00.
E           assert 'USER (user: user_requests_test) limit: 5.00 requests per 1 minute_rolling exceeded. Current usage: 5.00, request: 1.00.' in 'USER (model: test-model, user: user_requests_test) limit: 5.00 requests per 1 minute_rolling exceeded. Current usage: 5.00, request: 1.00.'

tests/accounting/test_comprehensive_limits.py:121: AssertionError
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 82f27c891782, initial_tables
INFO  [alembic.runtime.migration] Running upgrade 82f27c891782 -> ba9718840e75, add_notes_to_accounting_entry
_____________________ test_project_limit_with_model_limit ______________________

accounting_for_quota = <llm_accounting.LLMAccounting object at 0x7f7651513130>

    def test_project_limit_with_model_limit(accounting_for_quota: LLMAccounting):
        """Test interaction between project limit and model limit."""
        project_f = "ProjectF"
        project_g = "ProjectG"
        model_name = "special-model"
        with freeze_time("2023-01-01 12:00:00", tz_offset=0) as freezer:
            accounting_for_quota.set_usage_limit(LimitScope.MODEL, LimitType.REQUESTS, 3, TimeInterval.DAY, 1, model=model_name)
            accounting_for_quota.set_usage_limit(LimitScope.PROJECT, LimitType.REQUESTS, 2, TimeInterval.DAY, 1, model=model_name, project_name=project_f)
            accounting_for_quota.quota_service.refresh_limits_cache()

            add_usage(accounting_for_quota, freezer, model=model_name, cost=0.1, input_tokens=1, project_name=project_f)
            allowed, _ = accounting_for_quota.check_quota(model=model_name, cost=0.1, input_tokens=1, project_name=project_f, username="u", caller_name="c")
            assert allowed
            add_usage(accounting_for_quota, freezer, model=model_name, cost=0.1, input_tokens=1, project_name=project_f)

            allowed, message = accounting_for_quota.check_quota(model=model_name, cost=0.1, input_tokens=1, project_name=project_f, username="u", caller_name="c")
            assert not allowed, "Should be denied by ProjectF limit"
            assert message is not None
>           assert f"PROJECT (project: {project_f}) limit: 2.00 requests per 1 day exceeded. Current usage: 2.00, request: 1.00." in message
E           AssertionError: assert 'PROJECT (project: ProjectF) limit: 2.00 requests per 1 day exceeded. Current usage: 2.00, request: 1.00.' in 'PROJECT (model: special-model, project: ProjectF) limit: 2.00 requests per 1 day exceeded. Current usage: 2.00, request: 1.00.'

tests/core/test_project_quota_service.py:147: AssertionError
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 82f27c891782, initial_tables
INFO  [alembic.runtime.migration] Running upgrade 82f27c891782 -> ba9718840e75, add_notes_to_accounting_entry
_____________________ test_limit_message_for_project_scope _____________________

accounting_for_quota = <llm_accounting.LLMAccounting object at 0x7f7651bd13c0>

    def test_limit_message_for_project_scope(accounting_for_quota: LLMAccounting):
        """Test the limit exhaustion message for project-scoped limits."""
        project_name = "DetailProject"
        model_name = "detailed-model"
        with freeze_time("2023-01-01 12:00:00", tz_offset=0) as freezer:
            accounting_for_quota.set_usage_limit(
                scope=LimitScope.PROJECT,
                limit_type=LimitType.REQUESTS,
                max_value=1,
                interval_unit=TimeInterval.DAY,
                interval_value=1,
                project_name=project_name,
                model=model_name
            )
            accounting_for_quota.quota_service.refresh_limits_cache()
            add_usage(accounting_for_quota, freezer, model=model_name, cost=0.1, input_tokens=1, project_name=project_name)
            allowed, message = accounting_for_quota.check_quota(model=model_name, cost=0.1, input_tokens=1, project_name=project_name, username="u", caller_name="c")

            assert not allowed
            assert message is not None
>           assert f"PROJECT (project: {project_name}) limit: 1.00 requests per 1 day exceeded. Current usage: 1.00, request: 1.00." in message
E           AssertionError: assert 'PROJECT (project: DetailProject) limit: 1.00 requests per 1 day exceeded. Current usage: 1.00, request: 1.00.' in 'PROJECT (model: detailed-model, project: DetailProject) limit: 1.00 requests per 1 day exceeded. Current usage: 1.00, request: 1.00.'

tests/core/test_project_quota_service.py:198: AssertionError
---------------------------- Captured stderr setup -----------------------------
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 82f27c891782, initial_tables
INFO  [alembic.runtime.migration] Running upgrade 82f27c891782 -> ba9718840e75, add_notes_to_accounting_entry
=============================== warnings summary ===============================
../usr/local/lib/python3.10/dist-packages/_pytest/config/__init__.py:1441
  /usr/local/lib/python3.10/dist-packages/_pytest/config/__init__.py:1441: PytestConfigWarning: Unknown config option: asyncio_default_fixture_loop_scope

    self._warn_or_fail_if_strict(f"Unknown config option: {key}\n")

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/accounting/test_account_model_limits.py::test_account_model_requests_per_minute
FAILED tests/accounting/test_account_model_limits.py::test_account_model_requests_per_day
FAILED tests/accounting/test_account_model_limits.py::test_account_model_completion_tokens_per_minute
FAILED tests/accounting/test_account_model_limits.py::test_account_model_completion_tokens_per_day
FAILED tests/accounting/test_comprehensive_limits.py::test_comprehensive_limit_scenarios
FAILED tests/core/test_project_quota_service.py::test_project_limit_with_model_limit
FAILED tests/core/test_project_quota_service.py::test_limit_message_for_project_scope
====== 7 failed, 194 passed, 24 skipped, 1 deselected, 1 warning in 8.34s ======
